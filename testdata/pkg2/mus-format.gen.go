// Code generated by musgen-go. DO NOT EDIT.

package pkg2

import (
	com "github.com/mus-format/common-go"
	slops "github.com/mus-format/mus-go/options/slice"
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/raw"
	"github.com/mus-format/mus-go/varint"
	"github.com/mus-format/musgen-go/testdata"
)

var (
	slice38BHdMWos2mΣopΔw8EBC4wΞΞ = ord.NewValidSliceSer[[]int](sliceEA4T75wluywAmMa4P9rKBAΞΞ, slops.WithLenValidator[[]int](com.ValidatorFn[int](testdata.ValidateLength1)))
	sliceEA4T75wluywAmMa4P9rKBAΞΞ = ord.NewValidSliceSer[int](raw.Int, slops.WithLenValidator[int](com.ValidatorFn[int](testdata.ValidateLength1)))
	sliceXbo5m8EW2RY16Z00mΣBebQΞΞ = ord.NewSliceSer[[]int](sliceyYo56cJmna1pH61A8fbΣLQΞΞ)
	sliceyYo56cJmna1pH61A8fbΣLQΞΞ = ord.NewSliceSer[int](varint.Int)
)

var StructMUS = structMUS{}

type structMUS struct{}

func (s structMUS) Marshal(v Struct, bs []byte) (n int) {
	n = varint.Float32.Marshal(v.Float32, bs)
	n += varint.Float64.Marshal(v.Float64, bs[n:])
	n += varint.Uint8.Marshal(v.Byte, bs[n:])
	n += ord.Bool.Marshal(v.Bool, bs[n:])
	return n + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Marshal(v.Slice, bs[n:])
}

func (s structMUS) Unmarshal(bs []byte) (v Struct, n int, err error) {
	v.Float32, n, err = varint.Float32.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Float64, n1, err = varint.Float64.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Byte, n1, err = varint.Uint8.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Bool, n1, err = ord.Bool.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Slice, n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Unmarshal(bs[n:])
	n += n1
	return
}

func (s structMUS) Size(v Struct) (size int) {
	size = varint.Float32.Size(v.Float32)
	size += varint.Float64.Size(v.Float64)
	size += varint.Uint8.Size(v.Byte)
	size += ord.Bool.Size(v.Bool)
	return size + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Size(v.Slice)
}

func (s structMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Float32.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Float64.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.Uint8.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.Bool.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Skip(bs[n:])
	n += n1
	return
}

var IgnoreFieldStructMUS = ignoreFieldStructMUS{}

type ignoreFieldStructMUS struct{}

func (s ignoreFieldStructMUS) Marshal(v IgnoreFieldStruct, bs []byte) (n int) {
	n = varint.Float32.Marshal(v.Float32, bs)
	n += varint.Uint8.Marshal(v.Byte, bs[n:])
	n += ord.Bool.Marshal(v.Bool, bs[n:])
	return n + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Marshal(v.Slice, bs[n:])
}

func (s ignoreFieldStructMUS) Unmarshal(bs []byte) (v IgnoreFieldStruct, n int, err error) {
	v.Float32, n, err = varint.Float32.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Byte, n1, err = varint.Uint8.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Bool, n1, err = ord.Bool.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Slice, n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Unmarshal(bs[n:])
	n += n1
	return
}

func (s ignoreFieldStructMUS) Size(v IgnoreFieldStruct) (size int) {
	size = varint.Float32.Size(v.Float32)
	size += varint.Uint8.Size(v.Byte)
	size += ord.Bool.Size(v.Bool)
	return size + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Size(v.Slice)
}

func (s ignoreFieldStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Float32.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Uint8.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.Bool.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Skip(bs[n:])
	n += n1
	return
}

var ValidFieldStructMUS = validFieldStructMUS{}

type validFieldStructMUS struct{}

func (s validFieldStructMUS) Marshal(v ValidFieldStruct, bs []byte) (n int) {
	n = varint.Float32.Marshal(v.Float32, bs)
	n += varint.Float64.Marshal(v.Float64, bs[n:])
	n += varint.Uint8.Marshal(v.Byte, bs[n:])
	n += ord.Bool.Marshal(v.Bool, bs[n:])
	return n + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Marshal(v.Slice, bs[n:])
}

func (s validFieldStructMUS) Unmarshal(bs []byte) (v ValidFieldStruct, n int, err error) {
	v.Float32, n, err = varint.Float32.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Float64, n1, err = varint.Float64.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Byte, n1, err = varint.Uint8.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	err = testdata.ValidateZeroValue[byte](v.Byte)
	if err != nil {
		return
	}
	v.Bool, n1, err = ord.Bool.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Slice, n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Unmarshal(bs[n:])
	n += n1
	return
}

func (s validFieldStructMUS) Size(v ValidFieldStruct) (size int) {
	size = varint.Float32.Size(v.Float32)
	size += varint.Float64.Size(v.Float64)
	size += varint.Uint8.Size(v.Byte)
	size += ord.Bool.Size(v.Bool)
	return size + sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Size(v.Slice)
}

func (s validFieldStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Float32.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Float64.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.Uint8.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.Bool.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = sliceXbo5m8EW2RY16Z00mΣBebQΞΞ.Skip(bs[n:])
	n += n1
	return
}

var ElemStructMUS = elemStructMUS{}

type elemStructMUS struct{}

func (s elemStructMUS) Marshal(v ElemStruct, bs []byte) (n int) {
	n = varint.Float32.Marshal(v.Float32, bs)
	n += varint.Float64.Marshal(v.Float64, bs[n:])
	n += varint.Uint8.Marshal(v.Byte, bs[n:])
	n += ord.Bool.Marshal(v.Bool, bs[n:])
	return n + slice38BHdMWos2mΣopΔw8EBC4wΞΞ.Marshal(v.Slice, bs[n:])
}

func (s elemStructMUS) Unmarshal(bs []byte) (v ElemStruct, n int, err error) {
	v.Float32, n, err = varint.Float32.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Float64, n1, err = varint.Float64.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Byte, n1, err = varint.Uint8.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Bool, n1, err = ord.Bool.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Slice, n1, err = slice38BHdMWos2mΣopΔw8EBC4wΞΞ.Unmarshal(bs[n:])
	n += n1
	return
}

func (s elemStructMUS) Size(v ElemStruct) (size int) {
	size = varint.Float32.Size(v.Float32)
	size += varint.Float64.Size(v.Float64)
	size += varint.Uint8.Size(v.Byte)
	size += ord.Bool.Size(v.Bool)
	return size + slice38BHdMWos2mΣopΔw8EBC4wΞΞ.Size(v.Slice)
}

func (s elemStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Float32.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Float64.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.Uint8.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.Bool.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = slice38BHdMWos2mΣopΔw8EBC4wΞΞ.Skip(bs[n:])
	n += n1
	return
}

var TimeStructMUS = timeStructMUS{}

type timeStructMUS struct{}

func (s timeStructMUS) Marshal(v TimeStruct, bs []byte) (n int) {
	n = varint.Float32.Marshal(v.Float32, bs)
	n += raw.TimeUnix.Marshal(v.Time, bs[n:])
	return n + ord.String.Marshal(v.String, bs[n:])
}

func (s timeStructMUS) Unmarshal(bs []byte) (v TimeStruct, n int, err error) {
	v.Float32, n, err = varint.Float32.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Time, n1, err = raw.TimeUnix.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.String, n1, err = ord.String.Unmarshal(bs[n:])
	n += n1
	return
}

func (s timeStructMUS) Size(v TimeStruct) (size int) {
	size = varint.Float32.Size(v.Float32)
	size += raw.TimeUnix.Size(v.Time)
	return size + ord.String.Size(v.String)
}

func (s timeStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Float32.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = raw.TimeUnix.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.String.Skip(bs[n:])
	n += n1
	return
}
