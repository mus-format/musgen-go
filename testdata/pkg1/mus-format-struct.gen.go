// Code generated by musgen-go. DO NOT EDIT.

package pkg1

import (
	"github.com/mus-format/mus-go"
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/varint"
	"github.com/mus-format/musgen-go/testdata/pkg2"
)

func MarshalComplexStructMUS(v ComplexStruct, bs []byte) (n int) {
	n = ord.MarshalBool(v.Bool, bs[n:])
	n += varint.MarshalUint8(v.Byte, bs[n:])
	n += varint.MarshalInt8(v.Int8, bs[n:])
	n += varint.MarshalInt16(v.Int16, bs[n:])
	n += varint.MarshalInt32(v.Int32, bs[n:])
	n += varint.MarshalInt64(v.Int64, bs[n:])
	n += varint.MarshalUint8(v.Uint8, bs[n:])
	n += varint.MarshalUint16(v.Uint16, bs[n:])
	n += varint.MarshalUint32(v.Uint32, bs[n:])
	n += varint.MarshalUint64(v.Uint64, bs[n:])
	n += varint.MarshalFloat32(v.Float32, bs[n:])
	n += varint.MarshalFloat64(v.Float64, bs[n:])
	n += ord.MarshalString(v.String, nil, bs[n:])
	n += ord.MarshalPtr[string](v.PtrString, mus.MarshallerFn[string](func(t string, bs []byte) (n int) { return ord.MarshalString(t, nil, bs[n:]) }), bs[n:])
	n += MarshalSliceAliasMUS(v.Alias, bs[n:])
	n += ord.MarshalPtr[Struct](v.Ptr, mus.MarshallerFn[Struct](MarshalStructMUS), bs[n:])
	n += ord.MarshalPtr[string](v.NilPtr, mus.MarshallerFn[string](func(t string, bs []byte) (n int) { return ord.MarshalString(t, nil, bs[n:]) }), bs[n:])
	n += pkg2.MarshalStructMUS(v.AnotherPkgStruct, bs[n:])
	n += MarshalInterfaceMUS(v.Interface, bs[n:])
	n += ord.MarshalByteSlice(v.SliceByte,
		nil,
		bs[n:])
	n += ord.MarshalSlice[Struct](v.SliceStruct,
		nil,
		mus.MarshallerFn[Struct](MarshalStructMUS),
		bs[n:])
	n += ord.MarshalSlice[int](v.Array[:],
		nil,
		mus.MarshallerFn[int](varint.MarshalInt),
		bs[n:])
	n += ord.MarshalPtr[[3]int](v.PtrArray, mus.MarshallerFn[[3]int](func(t [3]int, bs []byte) (n int) {
		return ord.MarshalSlice[int](t[:],
			nil,
			mus.MarshallerFn[int](varint.MarshalInt),
			bs[n:])
	}), bs[n:])
	return n + ord.MarshalMap[float32, map[IntAlias][]Struct](v.Map, nil,
		mus.MarshallerFn[float32](varint.MarshalFloat32),
		mus.MarshallerFn[map[IntAlias][]Struct](func(t map[IntAlias][]Struct, bs []byte) (n int) {
			return ord.MarshalMap[IntAlias, []Struct](t, nil,
				mus.MarshallerFn[IntAlias](MarshalIntAliasMUS),
				mus.MarshallerFn[[]Struct](func(t []Struct, bs []byte) (n int) {
					return ord.MarshalSlice[Struct](t,
						nil,
						mus.MarshallerFn[Struct](MarshalStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
}

func UnmarshalComplexStructMUS(bs []byte) (v ComplexStruct, n int, err error) {
	v.Bool, n, err = ord.UnmarshalBool(bs[n:])
	if err != nil {
		return
	}
	var n1 int
	v.Byte, n1, err = varint.UnmarshalUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int8, n1, err = varint.UnmarshalInt8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int16, n1, err = varint.UnmarshalInt16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int32, n1, err = varint.UnmarshalInt32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int64, n1, err = varint.UnmarshalInt64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint8, n1, err = varint.UnmarshalUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint16, n1, err = varint.UnmarshalUint16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint32, n1, err = varint.UnmarshalUint32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint64, n1, err = varint.UnmarshalUint64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Float32, n1, err = varint.UnmarshalFloat32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Float64, n1, err = varint.UnmarshalFloat64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.String, n1, err = ord.UnmarshalString(nil, bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.PtrString, n1, err = ord.UnmarshalPtr[string](mus.UnmarshallerFn[string](func(bs []byte) (t string, n int, err error) { return ord.UnmarshalString(nil, bs[n:]) }), bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Alias, n1, err = UnmarshalSliceAliasMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Ptr, n1, err = ord.UnmarshalPtr[Struct](mus.UnmarshallerFn[Struct](UnmarshalStructMUS), bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.NilPtr, n1, err = ord.UnmarshalPtr[string](mus.UnmarshallerFn[string](func(bs []byte) (t string, n int, err error) { return ord.UnmarshalString(nil, bs[n:]) }), bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.AnotherPkgStruct, n1, err = pkg2.UnmarshalStructMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Interface, n1, err = UnmarshalInterfaceMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.SliceByte, n1, err = ord.UnmarshalByteSlice(nil,
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.SliceStruct, n1, err = ord.UnmarshalSlice[Struct](nil,
		mus.UnmarshallerFn[Struct](UnmarshalStructMUS),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	vArray, n1, err := ord.UnmarshalSlice[int](nil,
		mus.UnmarshallerFn[int](varint.UnmarshalInt),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Array = ([3]int)(vArray)
	v.PtrArray, n1, err = ord.UnmarshalPtr[[3]int](mus.UnmarshallerFn[[3]int](func(bs []byte) (t [3]int, n int, err error) {
		ta, n, err := ord.UnmarshalSlice[int](nil,
			mus.UnmarshallerFn[int](varint.UnmarshalInt),
			bs[n:])
		if err != nil {
			return
		}
		t = ([3]int)(ta)
		return
	}), bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Map, n1, err = ord.UnmarshalMap[float32, map[IntAlias][]Struct](nil,
		mus.UnmarshallerFn[float32](varint.UnmarshalFloat32),
		mus.UnmarshallerFn[map[IntAlias][]Struct](func(bs []byte) (t map[IntAlias][]Struct, n int, err error) {
			return ord.UnmarshalMap[IntAlias, []Struct](nil,
				mus.UnmarshallerFn[IntAlias](UnmarshalIntAliasMUS),
				mus.UnmarshallerFn[[]Struct](func(bs []byte) (t []Struct, n int, err error) {
					return ord.UnmarshalSlice[Struct](nil,
						mus.UnmarshallerFn[Struct](UnmarshalStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
	n += n1
	return
}

func SizeComplexStructMUS(v ComplexStruct) (size int) {
	size = ord.SizeBool(v.Bool)
	size += varint.SizeUint8(v.Byte)
	size += varint.SizeInt8(v.Int8)
	size += varint.SizeInt16(v.Int16)
	size += varint.SizeInt32(v.Int32)
	size += varint.SizeInt64(v.Int64)
	size += varint.SizeUint8(v.Uint8)
	size += varint.SizeUint16(v.Uint16)
	size += varint.SizeUint32(v.Uint32)
	size += varint.SizeUint64(v.Uint64)
	size += varint.SizeFloat32(v.Float32)
	size += varint.SizeFloat64(v.Float64)
	size += ord.SizeString(v.String, nil)
	size += ord.SizePtr[string](v.PtrString, mus.SizerFn[string](func(t string) (size int) { return ord.SizeString(t, nil) }))
	size += SizeSliceAliasMUS(v.Alias)
	size += ord.SizePtr[Struct](v.Ptr, mus.SizerFn[Struct](SizeStructMUS))
	size += ord.SizePtr[string](v.NilPtr, mus.SizerFn[string](func(t string) (size int) { return ord.SizeString(t, nil) }))
	size += pkg2.SizeStructMUS(v.AnotherPkgStruct)
	size += SizeInterfaceMUS(v.Interface)
	size += ord.SizeByteSlice(v.SliceByte,
		nil)
	size += ord.SizeSlice[Struct](v.SliceStruct,
		nil,
		mus.SizerFn[Struct](SizeStructMUS))
	size += ord.SizeSlice[int](v.Array[:],
		nil,
		mus.SizerFn[int](varint.SizeInt))
	size += ord.SizePtr[[3]int](v.PtrArray, mus.SizerFn[[3]int](func(t [3]int) (size int) {
		return ord.SizeSlice[int](t[:],
			nil,
			mus.SizerFn[int](varint.SizeInt))
	}))
	return size + ord.SizeMap[float32, map[IntAlias][]Struct](v.Map, nil,
		mus.SizerFn[float32](varint.SizeFloat32),
		mus.SizerFn[map[IntAlias][]Struct](func(t map[IntAlias][]Struct) (size int) {
			return ord.SizeMap[IntAlias, []Struct](t, nil,
				mus.SizerFn[IntAlias](SizeIntAliasMUS),
				mus.SizerFn[[]Struct](func(t []Struct) (size int) {
					return ord.SizeSlice[Struct](t,
						nil,
						mus.SizerFn[Struct](SizeStructMUS))
				}))
		}))
}

func SkipComplexStructMUS(bs []byte) (n int, err error) {
	n, err = ord.SkipBool(bs[n:])
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.SkipUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipFloat32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipFloat64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipString(nil, bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipPtr(mus.SkipperFn(func(bs []byte) (n int, err error) { return ord.SkipString(nil, bs[n:]) }), bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = SkipSliceAliasMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipPtr(mus.SkipperFn(SkipStructMUS), bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipPtr(mus.SkipperFn(func(bs []byte) (n int, err error) { return ord.SkipString(nil, bs[n:]) }), bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = pkg2.SkipStructMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = SkipInterfaceMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipByteSlice(nil,
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipSlice(nil,
		mus.SkipperFn(SkipStructMUS),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipSlice(nil,
		mus.SkipperFn(varint.SkipInt),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipPtr(mus.SkipperFn(func(bs []byte) (n int, err error) {
		return ord.SkipSlice(nil,
			mus.SkipperFn(varint.SkipInt),
			bs[n:])
	}), bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipMap(nil,
		mus.SkipperFn(varint.SkipFloat32),
		mus.SkipperFn(func(bs []byte) (n int, err error) {
			return ord.SkipMap(nil,
				mus.SkipperFn(SkipIntAliasMUS),
				mus.SkipperFn(func(bs []byte) (n int, err error) {
					return ord.SkipSlice(nil,
						mus.SkipperFn(SkipStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
	n += n1
	return
}
