// Code generated by musgen-go. DO NOT EDIT.\n\npackage

package pkg1

import (
	"github.com/mus-format/mus-go"
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/varint"
	"github.com/mus-format/musgen-go/testdata/pkg2"
)

func MarshalComplexStructMUS(v ComplexStruct, bs []byte) (n int) {
	n = ord.MarshalBool(v.Bool, bs[n:])
	n += varint.MarshalUint8(v.Byte, bs[n:])
	n += varint.MarshalInt8(v.Int8, bs[n:])
	n += varint.MarshalInt16(v.Int16, bs[n:])
	n += varint.MarshalInt32(v.Int32, bs[n:])
	n += varint.MarshalInt64(v.Int64, bs[n:])
	n += varint.MarshalUint8(v.Uint8, bs[n:])
	n += varint.MarshalUint16(v.Uint16, bs[n:])
	n += varint.MarshalUint32(v.Uint32, bs[n:])
	n += varint.MarshalUint64(v.Uint64, bs[n:])
	n += varint.MarshalFloat32(v.Float32, bs[n:])
	n += varint.MarshalFloat64(v.Float64, bs[n:])
	n += ord.MarshalString(v.String, nil, bs[n:])
	n += MarshalSliceAliasMUS(v.Alias, bs[n:])
	n += ord.MarshalPtr[Struct](v.Ptr, mus.MarshallerFn[Struct](MarshalStructMUS), bs[n:])
	n += pkg2.MarshalStructMUS(v.AnotherPkgStruct, bs[n:])
	n += MarshalInterfaceMUS(v.Interface, bs[n:])
	n += ord.MarshalSlice[uint8](v.SliceByte,
		nil,
		mus.MarshallerFn[uint8](varint.MarshalUint8),
		bs[n:])
	n += ord.MarshalSlice[Struct](v.SliceStruct,
		nil,
		mus.MarshallerFn[Struct](MarshalStructMUS),
		bs[n:])
	return n + ord.MarshalMap[float32, map[IntAlias][]Struct](v.Map, nil,
		mus.MarshallerFn[float32](varint.MarshalFloat32),
		mus.MarshallerFn[map[IntAlias][]Struct](func(t map[IntAlias][]Struct, bs []byte) (n int) {
			return ord.MarshalMap[IntAlias, []Struct](t, nil,
				mus.MarshallerFn[IntAlias](MarshalIntAliasMUS),
				mus.MarshallerFn[[]Struct](func(t []Struct, bs []byte) (n int) {
					return ord.MarshalSlice[Struct](t,
						nil,
						mus.MarshallerFn[Struct](MarshalStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
}

func UnmarshalComplexStructMUS(bs []byte) (v ComplexStruct, n int, err error) {
	v.Bool, n, err = ord.UnmarshalBool(bs[n:])
	if err != nil {
		return
	}
	var n1 int
	v.Byte, n1, err = varint.UnmarshalUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int8, n1, err = varint.UnmarshalInt8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int16, n1, err = varint.UnmarshalInt16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int32, n1, err = varint.UnmarshalInt32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Int64, n1, err = varint.UnmarshalInt64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint8, n1, err = varint.UnmarshalUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint16, n1, err = varint.UnmarshalUint16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint32, n1, err = varint.UnmarshalUint32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Uint64, n1, err = varint.UnmarshalUint64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Float32, n1, err = varint.UnmarshalFloat32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Float64, n1, err = varint.UnmarshalFloat64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.String, n1, err = ord.UnmarshalString(nil, bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Alias, n1, err = UnmarshalSliceAliasMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Ptr, n1, err = ord.UnmarshalPtr[Struct](mus.UnmarshallerFn[Struct](UnmarshalStructMUS), bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.AnotherPkgStruct, n1, err = pkg2.UnmarshalStructMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Interface, n1, err = UnmarshalInterfaceMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.SliceByte, n1, err = ord.UnmarshalSlice[uint8](nil,
		mus.UnmarshallerFn[uint8](varint.UnmarshalUint8),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.SliceStruct, n1, err = ord.UnmarshalSlice[Struct](nil,
		mus.UnmarshallerFn[Struct](UnmarshalStructMUS),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.Map, n1, err = ord.UnmarshalMap[float32, map[IntAlias][]Struct](nil,
		mus.UnmarshallerFn[float32](varint.UnmarshalFloat32),
		mus.UnmarshallerFn[map[IntAlias][]Struct](func(bs []byte) (t map[IntAlias][]Struct, n int, err error) {
			return ord.UnmarshalMap[IntAlias, []Struct](nil,
				mus.UnmarshallerFn[IntAlias](UnmarshalIntAliasMUS),
				mus.UnmarshallerFn[[]Struct](func(bs []byte) (t []Struct, n int, err error) {
					return ord.UnmarshalSlice[Struct](nil,
						mus.UnmarshallerFn[Struct](UnmarshalStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
	n += n1
	return
}

func SizeComplexStructMUS(v ComplexStruct) (size int) {
	size = ord.SizeBool(v.Bool)
	size += varint.SizeUint8(v.Byte)
	size += varint.SizeInt8(v.Int8)
	size += varint.SizeInt16(v.Int16)
	size += varint.SizeInt32(v.Int32)
	size += varint.SizeInt64(v.Int64)
	size += varint.SizeUint8(v.Uint8)
	size += varint.SizeUint16(v.Uint16)
	size += varint.SizeUint32(v.Uint32)
	size += varint.SizeUint64(v.Uint64)
	size += varint.SizeFloat32(v.Float32)
	size += varint.SizeFloat64(v.Float64)
	size += ord.SizeString(v.String, nil)
	size += SizeSliceAliasMUS(v.Alias)
	size += ord.SizePtr[Struct](v.Ptr, mus.SizerFn[Struct](SizeStructMUS))
	size += pkg2.SizeStructMUS(v.AnotherPkgStruct)
	size += SizeInterfaceMUS(v.Interface)
	size += ord.SizeSlice[uint8](v.SliceByte,
		nil,
		mus.SizerFn[uint8](varint.SizeUint8))
	size += ord.SizeSlice[Struct](v.SliceStruct,
		nil,
		mus.SizerFn[Struct](SizeStructMUS))
	return size + ord.SizeMap[float32, map[IntAlias][]Struct](v.Map, nil,
		mus.SizerFn[float32](varint.SizeFloat32),
		mus.SizerFn[map[IntAlias][]Struct](func(t map[IntAlias][]Struct) (size int) {
			return ord.SizeMap[IntAlias, []Struct](t, nil,
				mus.SizerFn[IntAlias](SizeIntAliasMUS),
				mus.SizerFn[[]Struct](func(t []Struct) (size int) {
					return ord.SizeSlice[Struct](t,
						nil,
						mus.SizerFn[Struct](SizeStructMUS))
				}))
		}))
}

func SkipComplexStructMUS(bs []byte) (n int, err error) {
	n, err = ord.SkipBool(bs[n:])
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.SkipUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipInt64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint8(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint16(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipUint64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipFloat32(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = varint.SkipFloat64(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipString(nil, bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = SkipSliceAliasMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipPtr(mus.SkipperFn(SkipStructMUS), bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = pkg2.SkipStructMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = SkipInterfaceMUS(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipSlice(nil,
		mus.SkipperFn(varint.SkipUint8),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipSlice(nil,
		mus.SkipperFn(SkipStructMUS),
		bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = ord.SkipMap(nil,
		mus.SkipperFn(varint.SkipFloat32),
		mus.SkipperFn(func(bs []byte) (n int, err error) {
			return ord.SkipMap(nil,
				mus.SkipperFn(SkipIntAliasMUS),
				mus.SkipperFn(func(bs []byte) (n int, err error) {
					return ord.SkipSlice(nil,
						mus.SkipperFn(SkipStructMUS),
						bs[n:])
				}),
				bs[n:])
		}),
		bs[n:])
	n += n1
	return
}
