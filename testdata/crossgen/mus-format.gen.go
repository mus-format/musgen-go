// Code generated by musgen-go. DO NOT EDIT.

package testdata

import (
	"fmt"

	dts "github.com/mus-format/mus-dts-go"
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/varint"
	"github.com/mus-format/musgen-go/testdata/crossgen/pkg"
)

var (
	array9oaDpbHaiTfHlΣn6EnAyOQΞΞ = ord.NewArraySer[[3]pkg.MyInt, pkg.MyInt](pkg.MyIntMUS)
	arrayi2Rtrqgv9NFQnYKxiWHBkwΞΞ = ord.NewArraySer[[3]MyMap, MyMap](MyMapMUS)
	mapE26OLzcdVΔ4xBYH8lslLIQΞΞ   = ord.NewMapSer[int, pkg.MyInterface](varint.Int, MyInterfaceMUS)
	sliceCP2Gfy7mMk5ΔPyPPjFVlXgΞΞ = ord.NewSliceSer[pkg.MyInt](pkg.MyIntMUS)
)

var MySliceMUS = mySliceMUS{}

type mySliceMUS struct{}

func (s mySliceMUS) Marshal(v pkg.MySlice, bs []byte) (n int) {
	return sliceCP2Gfy7mMk5ΔPyPPjFVlXgΞΞ.Marshal([]pkg.MyInt(v), bs)
}

func (s mySliceMUS) Unmarshal(bs []byte) (v pkg.MySlice, n int, err error) {
	tmp, n, err := sliceCP2Gfy7mMk5ΔPyPPjFVlXgΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = pkg.MySlice(tmp)
	return
}

func (s mySliceMUS) Size(v pkg.MySlice) (size int) {
	return sliceCP2Gfy7mMk5ΔPyPPjFVlXgΞΞ.Size([]pkg.MyInt(v))
}

func (s mySliceMUS) Skip(bs []byte) (n int, err error) {
	return sliceCP2Gfy7mMk5ΔPyPPjFVlXgΞΞ.Skip(bs)
}

var MyStructMUS = myStructMUS{}

type myStructMUS struct{}

func (s myStructMUS) Marshal(v pkg.MyStruct, bs []byte) (n int) {
	n = varint.Int.Marshal(v.Int, bs)
	n += pkg.MyIntMUS.Marshal(v.MyInt, bs[n:])
	return n + MySliceMUS.Marshal(v.MySlice, bs[n:])
}

func (s myStructMUS) Unmarshal(bs []byte) (v pkg.MyStruct, n int, err error) {
	v.Int, n, err = varint.Int.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.MyInt, n1, err = pkg.MyIntMUS.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.MySlice, n1, err = MySliceMUS.Unmarshal(bs[n:])
	n += n1
	return
}

func (s myStructMUS) Size(v pkg.MyStruct) (size int) {
	size = varint.Int.Size(v.Int)
	size += pkg.MyIntMUS.Size(v.MyInt)
	return size + MySliceMUS.Size(v.MySlice)
}

func (s myStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Int.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = pkg.MyIntMUS.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = MySliceMUS.Skip(bs[n:])
	n += n1
	return
}

var MyMapMUS = myMapMUS{}

type myMapMUS struct{}

func (s myMapMUS) Marshal(v MyMap, bs []byte) (n int) {
	return mapE26OLzcdVΔ4xBYH8lslLIQΞΞ.Marshal(map[int]pkg.MyInterface(v), bs)
}

func (s myMapMUS) Unmarshal(bs []byte) (v MyMap, n int, err error) {
	tmp, n, err := mapE26OLzcdVΔ4xBYH8lslLIQΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = MyMap(tmp)
	return
}

func (s myMapMUS) Size(v MyMap) (size int) {
	return mapE26OLzcdVΔ4xBYH8lslLIQΞΞ.Size(map[int]pkg.MyInterface(v))
}

func (s myMapMUS) Skip(bs []byte) (n int, err error) {
	return mapE26OLzcdVΔ4xBYH8lslLIQΞΞ.Skip(bs)
}

var MyArrayMUS = myArrayMUS{}

type myArrayMUS struct{}

func (s myArrayMUS) Marshal(v pkg.MyArray[MyMap], bs []byte) (n int) {
	return arrayi2Rtrqgv9NFQnYKxiWHBkwΞΞ.Marshal([3]MyMap(v), bs)
}

func (s myArrayMUS) Unmarshal(bs []byte) (v pkg.MyArray[MyMap], n int, err error) {
	tmp, n, err := arrayi2Rtrqgv9NFQnYKxiWHBkwΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = pkg.MyArray[MyMap](tmp)
	return
}

func (s myArrayMUS) Size(v pkg.MyArray[MyMap]) (size int) {
	return arrayi2Rtrqgv9NFQnYKxiWHBkwΞΞ.Size([3]MyMap(v))
}

func (s myArrayMUS) Skip(bs []byte) (n int, err error) {
	return arrayi2Rtrqgv9NFQnYKxiWHBkwΞΞ.Skip(bs)
}

var MyAnotherArrayMUS = myAnotherArrayMUS{}

type myAnotherArrayMUS struct{}

func (s myAnotherArrayMUS) Marshal(v pkg.MyAnotherArray[pkg.MyInt], bs []byte) (n int) {
	return array9oaDpbHaiTfHlΣn6EnAyOQΞΞ.Marshal([3]pkg.MyInt(v), bs)
}

func (s myAnotherArrayMUS) Unmarshal(bs []byte) (v pkg.MyAnotherArray[pkg.MyInt], n int, err error) {
	tmp, n, err := array9oaDpbHaiTfHlΣn6EnAyOQΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = pkg.MyAnotherArray[pkg.MyInt](tmp)
	return
}

func (s myAnotherArrayMUS) Size(v pkg.MyAnotherArray[pkg.MyInt]) (size int) {
	return array9oaDpbHaiTfHlΣn6EnAyOQΞΞ.Size([3]pkg.MyInt(v))
}

func (s myAnotherArrayMUS) Skip(bs []byte) (n int, err error) {
	return array9oaDpbHaiTfHlΣn6EnAyOQΞΞ.Skip(bs)
}

var MyStructWithCrossgenMUS = myStructWithCrossgenMUS{}

type myStructWithCrossgenMUS struct{}

func (s myStructWithCrossgenMUS) Marshal(v MyStructWithCrossgen, bs []byte) (n int) {
	return MyInterfaceMUS.Marshal(v.Field1, bs)
}

func (s myStructWithCrossgenMUS) Unmarshal(bs []byte) (v MyStructWithCrossgen, n int, err error) {
	v.Field1, n, err = MyInterfaceMUS.Unmarshal(bs)
	return
}

func (s myStructWithCrossgenMUS) Size(v MyStructWithCrossgen) (size int) {
	return MyInterfaceMUS.Size(v.Field1)
}

func (s myStructWithCrossgenMUS) Skip(bs []byte) (n int, err error) {
	n, err = MyInterfaceMUS.Skip(bs)
	return
}

var MyStructDTS = dts.New[pkg.MyStruct](MyStructDTM, MyStructMUS)

var MyInterfaceMUS = myInterfaceMUS{}

type myInterfaceMUS struct{}

func (s myInterfaceMUS) Marshal(v pkg.MyInterface, bs []byte) (n int) {
	switch t := v.(type) {
	case pkg.MyStruct:
		return MyStructDTS.Marshal(t, bs)
	default:
		panic(fmt.Sprintf("unexpected %v type", t))
	}
}

func (s myInterfaceMUS) Unmarshal(bs []byte) (v pkg.MyInterface, n int, err error) {
	dtm, n, err := dts.DTMSer.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	switch dtm {
	case MyStructDTM:
		v, n1, err = MyStructDTS.UnmarshalData(bs[n:])
	default:
		err = fmt.Errorf("unexpected %v DTM", dtm)
		return
	}
	n += n1
	return
}

func (s myInterfaceMUS) Size(v pkg.MyInterface) (size int) {
	switch t := v.(type) {
	case pkg.MyStruct:
		return MyStructDTS.Size(t)
	default:
		panic(fmt.Sprintf("unexpected %v type", t))
	}
}

func (s myInterfaceMUS) Skip(bs []byte) (n int, err error) {
	dtm, n, err := dts.DTMSer.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	switch dtm {
	case MyStructDTM:
		n1, err = MyStructDTS.SkipData(bs[n:])
	default:
		err = fmt.Errorf("unexpected %v DTM", dtm)
		return
	}
	n += n1
	return
}
