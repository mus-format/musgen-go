// Code generated by musgen-go. DO NOT EDIT.

package testdata

import (
	"fmt"

	com "github.com/mus-format/common-go"
	dts "github.com/mus-format/dts-go"
	mapops "github.com/mus-format/mus-go/options/map"
	"github.com/mus-format/mus-go/ord"
	"github.com/mus-format/mus-go/varint"
	common_testdata "github.com/mus-format/musgen-go/testdata"
)

var (
	array4AWqFk0FnR2tszx85AMJ2QΞΞ = ord.NewArraySer[[3]int, int](varint.Int)
	maptEoDVAbHCEgHMqfIJJmW2QΞΞ   = ord.NewValidMapSer[MyArray[int], MyInt](MyArrayMUS, MyIntMUS, mapops.WithKeyValidator[MyArray[int], MyInt](com.ValidatorFn[MyArray[int]](common_testdata.ValidateZeroValue[MyArray[int]])), mapops.WithValueValidator[MyArray[int], MyInt](com.ValidatorFn[MyInt](common_testdata.ValidateZeroValue[MyInt])))
	sliceZmDSfTleaOj60i0aIfIVhAΞΞ = ord.NewSliceSer[MyInt](MyIntMUS)
)

var MyIntMUS = myIntMUS{}

type myIntMUS struct{}

func (s myIntMUS) Marshal(v MyInt, bs []byte) (n int) {
	return varint.Int.Marshal(int(v), bs)
}

func (s myIntMUS) Unmarshal(bs []byte) (v MyInt, n int, err error) {
	tmp, n, err := varint.Int.Unmarshal(bs)
	if err != nil {
		return
	}
	v = MyInt(tmp)
	return
}

func (s myIntMUS) Size(v MyInt) (size int) {
	return varint.Int.Size(int(v))
}

func (s myIntMUS) Skip(bs []byte) (n int, err error) {
	return varint.Int.Skip(bs)
}

var MySliceMUS = mySliceMUS{}

type mySliceMUS struct{}

func (s mySliceMUS) Marshal(v MySlice[MyInt], bs []byte) (n int) {
	return sliceZmDSfTleaOj60i0aIfIVhAΞΞ.Marshal([]MyInt(v), bs)
}

func (s mySliceMUS) Unmarshal(bs []byte) (v MySlice[MyInt], n int, err error) {
	tmp, n, err := sliceZmDSfTleaOj60i0aIfIVhAΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = MySlice[MyInt](tmp)
	return
}

func (s mySliceMUS) Size(v MySlice[MyInt]) (size int) {
	return sliceZmDSfTleaOj60i0aIfIVhAΞΞ.Size([]MyInt(v))
}

func (s mySliceMUS) Skip(bs []byte) (n int, err error) {
	return sliceZmDSfTleaOj60i0aIfIVhAΞΞ.Skip(bs)
}

var MyArrayMUS = myArrayMUS{}

type myArrayMUS struct{}

func (s myArrayMUS) Marshal(v MyArray[int], bs []byte) (n int) {
	return array4AWqFk0FnR2tszx85AMJ2QΞΞ.Marshal([3]int(v), bs)
}

func (s myArrayMUS) Unmarshal(bs []byte) (v MyArray[int], n int, err error) {
	tmp, n, err := array4AWqFk0FnR2tszx85AMJ2QΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = MyArray[int](tmp)
	return
}

func (s myArrayMUS) Size(v MyArray[int]) (size int) {
	return array4AWqFk0FnR2tszx85AMJ2QΞΞ.Size([3]int(v))
}

func (s myArrayMUS) Skip(bs []byte) (n int, err error) {
	return array4AWqFk0FnR2tszx85AMJ2QΞΞ.Skip(bs)
}

var MyMapMUS = myMapMUS{}

type myMapMUS struct{}

func (s myMapMUS) Marshal(v MyMap[MyArray[int], MyInt], bs []byte) (n int) {
	return maptEoDVAbHCEgHMqfIJJmW2QΞΞ.Marshal(map[MyArray[int]]MyInt(v), bs)
}

func (s myMapMUS) Unmarshal(bs []byte) (v MyMap[MyArray[int], MyInt], n int, err error) {
	tmp, n, err := maptEoDVAbHCEgHMqfIJJmW2QΞΞ.Unmarshal(bs)
	if err != nil {
		return
	}
	v = MyMap[MyArray[int], MyInt](tmp)
	return
}

func (s myMapMUS) Size(v MyMap[MyArray[int], MyInt]) (size int) {
	return maptEoDVAbHCEgHMqfIJJmW2QΞΞ.Size(map[MyArray[int]]MyInt(v))
}

func (s myMapMUS) Skip(bs []byte) (n int, err error) {
	return maptEoDVAbHCEgHMqfIJJmW2QΞΞ.Skip(bs)
}

var MyStructMUS = myStructMUS{}

type myStructMUS struct{}

func (s myStructMUS) Marshal(v MyStruct[MySlice[MyInt]], bs []byte) (n int) {
	n = MySliceMUS.Marshal(v.T, bs)
	return n + varint.Int.Marshal(v.Int, bs[n:])
}

func (s myStructMUS) Unmarshal(bs []byte) (v MyStruct[MySlice[MyInt]], n int, err error) {
	v.T, n, err = MySliceMUS.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.Int, n1, err = varint.Int.Unmarshal(bs[n:])
	n += n1
	return
}

func (s myStructMUS) Size(v MyStruct[MySlice[MyInt]]) (size int) {
	size = MySliceMUS.Size(v.T)
	return size + varint.Int.Size(v.Int)
}

func (s myStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = MySliceMUS.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = varint.Int.Skip(bs[n:])
	n += n1
	return
}

var MyDoubleParamStructMUS = myDoubleParamStructMUS{}

type myDoubleParamStructMUS struct{}

func (s myDoubleParamStructMUS) Marshal(v MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]], bs []byte) (n int) {
	n = varint.Int.Marshal(v.T, bs)
	return n + MyStructMUS.Marshal(v.V, bs[n:])
}

func (s myDoubleParamStructMUS) Unmarshal(bs []byte) (v MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]], n int, err error) {
	v.T, n, err = varint.Int.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.V, n1, err = MyStructMUS.Unmarshal(bs[n:])
	n += n1
	return
}

func (s myDoubleParamStructMUS) Size(v MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]]) (size int) {
	size = varint.Int.Size(v.T)
	return size + MyStructMUS.Size(v.V)
}

func (s myDoubleParamStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = varint.Int.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = MyStructMUS.Skip(bs[n:])
	n += n1
	return
}

var MyTripleParamStructMUS = myTripleParamStructMUS{}

type myTripleParamStructMUS struct{}

func (s myTripleParamStructMUS) Marshal(v MyTripleParamStruct[MySlice[MyInt], MyInterface[MyInt], MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]]], bs []byte) (n int) {
	n = MySliceMUS.Marshal(v.T, bs)
	n += MyInterfaceMUS.Marshal(v.V, bs[n:])
	return n + MyDoubleParamStructMUS.Marshal(v.N, bs[n:])
}

func (s myTripleParamStructMUS) Unmarshal(bs []byte) (v MyTripleParamStruct[MySlice[MyInt], MyInterface[MyInt], MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]]], n int, err error) {
	v.T, n, err = MySliceMUS.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	v.V, n1, err = MyInterfaceMUS.Unmarshal(bs[n:])
	n += n1
	if err != nil {
		return
	}
	v.N, n1, err = MyDoubleParamStructMUS.Unmarshal(bs[n:])
	n += n1
	return
}

func (s myTripleParamStructMUS) Size(v MyTripleParamStruct[MySlice[MyInt], MyInterface[MyInt], MyDoubleParamStruct[int, MyStruct[MySlice[MyInt]]]]) (size int) {
	size = MySliceMUS.Size(v.T)
	size += MyInterfaceMUS.Size(v.V)
	return size + MyDoubleParamStructMUS.Size(v.N)
}

func (s myTripleParamStructMUS) Skip(bs []byte) (n int, err error) {
	n, err = MySliceMUS.Skip(bs)
	if err != nil {
		return
	}
	var n1 int
	n1, err = MyInterfaceMUS.Skip(bs[n:])
	n += n1
	if err != nil {
		return
	}
	n1, err = MyDoubleParamStructMUS.Skip(bs[n:])
	n += n1
	return
}

var ImplMUS = implMUS{}

type implMUS struct{}

func (s implMUS) Marshal(v Impl[MyInt], bs []byte) (n int) {
	return
}

func (s implMUS) Unmarshal(bs []byte) (v Impl[MyInt], n int, err error) {
	return
}

func (s implMUS) Size(v Impl[MyInt]) (size int) {
	return
}

func (s implMUS) Skip(bs []byte) (n int, err error) {
	return
}

var ImplDTS = dts.New[Impl[MyInt]](ImplDTM, ImplMUS)

var MyInterfaceMUS = myInterfaceMUS{}

type myInterfaceMUS struct{}

func (s myInterfaceMUS) Marshal(v MyInterface[MyInt], bs []byte) (n int) {
	switch t := v.(type) {
	case Impl[MyInt]:
		return ImplDTS.Marshal(t, bs)
	default:
		panic(fmt.Sprintf(com.ErrorPrefix+"unexpected %v type", t))
	}
}

func (s myInterfaceMUS) Unmarshal(bs []byte) (v MyInterface[MyInt], n int, err error) {
	dtm, n, err := dts.DTMSer.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	switch dtm {
	case ImplDTM:
		v, n1, err = ImplDTS.UnmarshalData(bs[n:])
	default:
		err = fmt.Errorf(com.ErrorPrefix+"unexpected %v DTM", dtm)
		return
	}
	n += n1
	return
}

func (s myInterfaceMUS) Size(v MyInterface[MyInt]) (size int) {
	switch t := v.(type) {
	case Impl[MyInt]:
		return ImplDTS.Size(t)
	default:
		panic(fmt.Sprintf(com.ErrorPrefix+"unexpected %v type", t))
	}
}

func (s myInterfaceMUS) Skip(bs []byte) (n int, err error) {
	dtm, n, err := dts.DTMSer.Unmarshal(bs)
	if err != nil {
		return
	}
	var n1 int
	switch dtm {
	case ImplDTM:
		n1, err = ImplDTS.SkipData(bs[n:])
	default:
		err = fmt.Errorf(com.ErrorPrefix+"unexpected %v DTM", dtm)
		return
	}
	n += n1
	return
}
